/* Autogenerated by /usr/bin/halcompile on Mon Sep 21 19:11:53 2020 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:turret_1325f30:LinuxCNC HAL for 1325f30 turret tool changer");
MODULE_INFO(linuxcnc, "pin:sens-##:bit:(32, 'personality +1'):in::None:None");
MODULE_INFO(linuxcnc, "pin:fix:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:change:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:number:s32:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:reset:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:fwd:bit:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:rev:bit:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:err:bit:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:changed:bit:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:current-position:s32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:state:s32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:timer:float:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:timer-fix:float:0:out::None:None");
MODULE_INFO(linuxcnc, "param:timeout:float:0:rw::40.0:None");
MODULE_INFO(linuxcnc, "param:timeout-fix:float:0:rw::1.0:None");
MODULE_INFO(linuxcnc, "funct:_:1:");
MODULE_INFO(linuxcnc, "descr:\nTurret with one motor, fwd for unlock and rev for fixing. Individual sensors for each tool, and additional sensor for fixing.\n");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    int _personality;
    hal_bit_t *sens[32];
    hal_bit_t *fix;
    hal_bit_t *change;
    hal_s32_t *number;
    hal_bit_t *reset;
    hal_bit_t *fwd;
    hal_bit_t *rev;
    hal_bit_t *err;
    hal_bit_t *changed;
    hal_s32_t *current_position;
    hal_s32_t *state;
    hal_float_t *timer;
    hal_float_t *timer_fix;
    hal_float_t timeout;
    hal_float_t timeout_fix;
    bool last_change;

};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg, long personality) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int j = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    inst->_personality = personality;
    if((personality +1) > (32)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin sens-##: Requested size %d exceeds max size %d\n",(int)personality +1, (int)32);
        return -ENOSPC;
    }
    for(j=0; j < (personality +1); j++) {
        r = hal_pin_bit_newf(HAL_IN, &(inst->sens[j]), comp_id,
            "%s.sens-%02d", prefix, j);
        if(r != 0) return r;
    }
    r = hal_pin_bit_newf(HAL_IN, &(inst->fix), comp_id,
        "%s.fix", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->change), comp_id,
        "%s.change", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->number), comp_id,
        "%s.number", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->reset), comp_id,
        "%s.reset", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->fwd), comp_id,
        "%s.fwd", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->rev), comp_id,
        "%s.rev", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->err), comp_id,
        "%s.err", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->changed), comp_id,
        "%s.changed", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->current_position), comp_id,
        "%s.current-position", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->state), comp_id,
        "%s.state", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->timer), comp_id,
        "%s.timer", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->timer_fix), comp_id,
        "%s.timer-fix", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->timeout), comp_id,
        "%s.timeout", prefix);
    inst->timeout = 40.0;
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->timeout_fix), comp_id,
        "%s.timeout-fix", prefix);
    inst->timeout_fix = 1.0;
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
RTAPI_MP_INT(count, "number of turret_1325f30");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of turret_1325f30");
static int personality[64] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
RTAPI_MP_ARRAY_INT(personality, 64, "personality of each turret_1325f30");

            static int p_value(char* cname, char *name, int idx) {
                int ans = personality[idx%64];
                if (idx >= 64) {
            

                    if (name==NULL) {
                        rtapi_print_msg(RTAPI_MSG_ERR,"%s: instance %d assigned personality=%d(=%#0x)\n",
                                        cname, idx, ans, ans);
                    } else {
                        rtapi_print_msg(RTAPI_MSG_ERR,"%s: name %s assigned personality=%d(=%#0x)\n",
                                        cname, name, ans, ans);
                    }
                }
                return ans;
            }
            
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("turret_1325f30");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "turret-1325f30.%d", i);
            r = export(buf, i, p_value("turret_1325f30", buf, i) );
            if(r != 0) break;
       }
    } else {
        int j,idx;
        char *ptr;
        char buf[HAL_NAME_LEN+1];
        ptr = names;
        idx = 0;
        for (i=0,j=0; i <= strlen(names); i++) {
            buf[j] = *(ptr+i);
            if ( (*(ptr+i) == ',') || (*(ptr+i) == 0) ) {
                buf[j] = 0;
                r = export(buf, idx, p_value("turret_1325f30", buf, idx) );
                if (*(ptr+i+1) == 0) {break;}
                idx++;
                if(r != 0) {break;}
                j=0;
            } else {
                j++;
            }
        }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef sens
#define sens(i) (0+*(__comp_inst->sens[i]))
#undef fix
#define fix (0+*__comp_inst->fix)
#undef change
#define change (0+*__comp_inst->change)
#undef number
#define number (0+*__comp_inst->number)
#undef reset
#define reset (0+*__comp_inst->reset)
#undef fwd
#define fwd (*__comp_inst->fwd)
#undef rev
#define rev (*__comp_inst->rev)
#undef err
#define err (*__comp_inst->err)
#undef changed
#define changed (*__comp_inst->changed)
#undef current_position
#define current_position (*__comp_inst->current_position)
#undef state
#define state (*__comp_inst->state)
#undef timer
#define timer (*__comp_inst->timer)
#undef timer_fix
#define timer_fix (*__comp_inst->timer_fix)
#undef timeout
#define timeout (__comp_inst->timeout)
#undef timeout_fix
#define timeout_fix (__comp_inst->timeout_fix)
#undef last_change
#define last_change (__comp_inst->last_change)
#undef personality
#define personality (__comp_inst->_personality)


#line 30 "turret_1325f30.comp"



// loadrt turret_1325f30 personality=10
#define ERROR 0
#define IDLE 1
#define SEARCH 2
#define FIX 3
#define FIXED 4


FUNCTION(_) {
	for (int i = 0; i<personality; i++){
		if (sens(i)){
			current_position = i;
			break;
		}
	}
	switch (state){
		case ERROR :
			fwd = 0;
			rev = 0;
			err = 1;
			if (reset) {err = 0; state = IDLE;}
			break;
		case IDLE :
			fwd = 0;
			rev = 0;
			changed = 0;
			if (change && !last_change) {
				state = SEARCH;
				timer = timeout;
			}
			break;
		case SEARCH :
			timer -= fperiod; 
			if (timer < 0) state = ERROR; /// too long for tool selection! timeout reached
			fwd = 1;
			rev = 0;
			if (current_position == number) {
				state=FIX;
				timer_fix = timeout_fix;
			}
			break;
		case FIX :
			timer_fix -= fperiod; 
			if (timer_fix < 0) state = ERROR;  /// too long for FIX! timeout reached
			fwd = 0;
			rev = 1;
			if (fix) {
				if (current_position == number) state = FIXED;
				else state = SEARCH; // Wrong instrument! Do the search again.
			}		
			break;
		case FIXED :
			fwd = 0;
			rev = 0;
			changed = 1;
			if (!change) {state = IDLE;}		
			break;		
		
	}	
	last_change = change;
}

static int __comp_get_data_size(void) { return 0; }
